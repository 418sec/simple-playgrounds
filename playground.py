import pygame
import pymunk
from entities import entity, agent, actionable_object, yielder_object, basic_object

from pygame.color import THECOLORS

import pymunk.pygame_util
import scenes

import random

from utils.config import *
#TODO: implement simulation steps, size_envir, multithreading



class Playground(object):

    def __init__(self, scene_parameters , game_parameters, engine_parameters , agent_parameters = None ):
        """
        Instantiate an environment with the following parameters
        :param shape : tuple of size 2 with width and height of the environment
        :param objects : dict of kwargs for object initialization in the environment
        :param display : boolean, whether to display the environment
        """

        self.scene = scenes.SceneGenerator.create( scene_parameters )
        self.width, self.height = self.scene.total_area


        # Initialization of the "screen", the pygame Surface object that will represent the environment
        self.screen = None
        self.display_playground = engine_parameters['display_playground']

        if self.display_playground :
            self.screen = pygame.display.set_mode((self.width, self.height))
        else:
            self.screen = pygame.Surface((self.width, self.height))
        self.screen.set_alpha(None)

        # Initialization of the pymunk space, this space is responsible for modelling all the physics
        self.space = pymunk.Space()
        self.space.gravity = pymunk.Vec2d(0., 0.)
        self.space.collision_bias = 0
        self.space.collision_persistence = 1
        self.space.collision_slop = 0
        self.space.damping = SPACE_DAMPING

        # Data structures to save list of entities, and relations between them
        # TODO: better data structure, with classes
        self.physical_entities = {}
        self.yielders = {}

        self.relations = {}
        self.relations['basics'] = []
        self.relations['absorbables'] = []
        self.relations['actionables'] = { 'doors': {},
                                          'edibles': [],
                                          'distractors': [],
                                          'dispensers': {},
                                          'graspables': []
                                          }
        self.relations['yielders'] = {}

        # Store the temporary pinjoints for grasping
        self.grasped = []

        self.agents = {}

        self.timers = {}


        # TODO: later, replace by iterating over all entities generated by base scene
        for elem in self.scene.elements:
            self.addEntity( elem , add_to_basics = False)

        # TODO: add multiple agents
        self.addAgent( agent_parameters )

        # TODO: move to separate function for collision initialization

        # Collision handlers
        h_abs = self.space.add_collision_handler(collision_types['agent'], collision_types['absorbable'])
        h_abs.pre_solve = self.agent_absorbs

        h_act = self.space.add_collision_handler(collision_types['agent'], collision_types['activable'])
        h_act.pre_solve = self.agent_activates

        h_edible = self.space.add_collision_handler(collision_types['agent'], collision_types['edible'])
        h_edible.pre_solve = self.agent_eats

        h_grasps = self.space.add_collision_handler(collision_types['agent'], collision_types['graspable'])
        h_grasps.pre_solve = self.agent_grasps

        self.ind_image = 0


# TODO: refactor activate / actionate
# TODO: add debut flag for printing and displaying

    def addEntity(self, entity_params, add_to_basics = True):
        '''
        Create new entity and assign  it to corresponding dictionary
        Different dictionaries to deal with different logics

        :param entity_params: dictionary representing parameters of an entity. Human readable format.
        :return:
        '''

        # Create new entity, give it an id then add it to  list entities
        entity_type = entity_params.get('entity_type', False)

        #id = str(self.index_entities)
        # TODO: Class entity with counter / id
        #self.index_entities += 1
        # Add entity in relational data structure, and get shapes

        if entity_type == 'actionable' :

            new_entity = actionable_object.ActionableGenerator.create(entity_params)

            # TODO: verify that we need 2 steps and 2 pairs shape/body
            self.space.add(new_entity.body_sensor, new_entity.shape_sensor)
            self.space.add(new_entity.body_body, new_entity.shape_body)

            actionable_type =  new_entity.actionable_type

            id = new_entity.name_id

            if actionable_type == 'distractor':
                self.relations['actionables']['distractors'].append(id)

            elif actionable_type == 'edible':
                self.relations['actionables']['edibles'].append(id)

            elif actionable_type == 'dispenser':
                self.relations['actionables']['dispensers'][id] = []

            elif actionable_type == 'door':
                id_door = self.addEntity(new_entity.door_params)
                self.relations['actionables']['doors'][id] = id_door

            elif actionable_type == 'graspable':

                self.relations['actionables']['graspables'].append( id)
            # TODO: test exception
            else:
                raise ValueError('actionable type {} not implemented'.format(actionable_type) )

        elif entity_type == 'yielder':
            new_entity = yielder_object.YielderObject(entity_params)
            id = new_entity.name_id
            self.relations['yielders'][id] = []

        elif entity_type == 'absorbable':
            new_entity = basic_object.BasicObject(entity_params)
            id = new_entity.name_id
            self.space.add(new_entity.body_body, new_entity.shape_body)


        else:
            new_entity = basic_object.BasicObject(entity_params)
            id = new_entity.name_id

            if add_to_basics: self.relations['basics'].append(id)

            self.space.add(new_entity.body_body, new_entity.shape_body)

        if entity_type == 'yielder':
            self.yielders[id] = new_entity
        else:
            self.physical_entities[id] = new_entity

        return id

    def addAgent(self, agent_params):

        new_agent = agent.BasicAgent(agent_params, self.space)
        #self.space.add(new_agent.shape)

        self.agent = new_agent


    def reset(self):
        # Reset the environment
        self.__init__(**self.parameters)

    def reload_screen(self):
        # Update the screen of the environment
        self.screen.fill(THECOLORS["black"])
        self.draw()
        if self.display_playground :
            pygame.display.flip()

    ## Collision handlers

    def agent_absorbs(self, arbiter, space, data):

        absorbable_shape = arbiter.shapes[1]

        absorbable_id = [id for id in self.physical_entities if self.physical_entities[id].shape_body == absorbable_shape][0]
        absorbable = self.physical_entities[absorbable_id]

        reward = absorbable.reward

        self.space.remove(absorbable.shape_body, absorbable.body_body)
        self.physical_entities.pop(absorbable_id)
        if absorbable_id in self.relations['basics']:
            self.relations['basics'].remove(absorbable_id)

        # TODO: also if yielder

        for disp_id, disp_contain in self.relations['yielders'].items():
            if absorbable_id in disp_contain:
                disp_contain.remove(absorbable_id)

        for disp_id, disp_contain in self.relations['actionables']['dispensers'].items():
            if absorbable_id in disp_contain:
                disp_contain.remove(absorbable_id)


        # TODO: add reward and reset to zero at each ts
        self.agent.reward = reward
        self.agent.health += reward

        return True


    def agent_activates(self, arbiter, space, data):

        is_activating = self.agent.is_activating

        activable_shape = arbiter.shapes[1]

        all_activables =  list(self.relations['actionables']['doors'].keys()) + list(self.relations['actionables']['distractors']) + list(self.relations['actionables']['dispensers'].keys())

        activable_id = [id for id in all_activables if self.physical_entities[id].shape_sensor == activable_shape][0]
        activable = self.physical_entities[activable_id]

        if is_activating:

            self.agent.is_activating = False



            if activable.actionable_type == 'dispenser':


                if len(self.relations['actionables']['dispensers'][activable_id]) < activable.limit:
                    new_obj = activable.actionate()
                    id_new_object = self.addEntity(new_obj, add_to_basics = False)
                    self.relations['actionables']['dispensers'][activable_id].append(id_new_object)

            elif activable.actionable_type == 'door':

                if activable.door_closed:
                    activable.door_closed = False

                    door_id = self.relations['actionables']['doors'][activable_id]
                    door = self.physical_entities[door_id]

                    space.remove(door.body_body, door.shape_body)

                    self.timers[activable_id] = activable.time_open



            else:
                activable.actionate()

            print(self.physical_entities)
            print(self.relations)

        return True

    def agent_grasps(self, arbiter, space, data):

        is_grasping = self.agent.is_grasping

        activable_shape = arbiter.shapes[1]

        all_activables =  list(self.relations['actionables']['graspables'])

        activable_id = [id for id in all_activables if self.physical_entities[id].shape_sensor == activable_shape][0]
        activable = self.physical_entities[activable_id]

        if is_grasping and (activable.movable == True) and (activable_id not in self.grasped):

            # create new link
            self.is_grasping = False
            self.is_holding = True

            j1 = pymunk.PinJoint(activable.body_body, self.agent.body, (0,5), (0,-5))
            j2 = pymunk.PinJoint(activable.body_body, self.agent.body, (0,-5), (0,5))
            j3 = pymunk.PinJoint(activable.body_body, self.agent.body, (5,5), (0,5))
            j4 = pymunk.PinJoint(activable.body_body, self.agent.body, (5,-5), (0,5))

            self.space.add(j1, j2, j3, j4)

            self.grasped.append(j1)
            self.grasped.append(j2)
            self.grasped.append(j3)
            self.grasped.append(j4)

        return True



    # TODO: norm PEP8, is_eating -> b_eating ?
    def agent_eats(self, arbiter, space, data):

        is_eating = self.agent.is_eating

        sensor_shape = arbiter.shapes[1]
        edible_id = [id for id in self.relations['actionables']['edibles'] if self.physical_entities[id].shape_sensor == sensor_shape][0]
        edible = self.physical_entities[edible_id]

        if is_eating:

            self.agent.is_eating = False

            space.remove(edible.body_sensor, edible.shape_sensor)
            space.remove(edible.body_body, edible.shape_body)

            space.add_post_step_callback(self.eaten_shrinks, edible_id )

        return True

    def eaten_shrinks(self, space, edible_id):

        edible = self.physical_entities[edible_id]
        edible.actionate()

        self.agent.reward += edible.reward

        if edible.radius > 5 :

            self.space.add(edible.body_sensor, edible.shape_sensor)
            self.space.add(edible.body_body, edible.shape_body)

        else:
            self.physical_entities.pop(edible_id)
            self.relations['actionables']['edibles'].remove(edible_id)

        return True

    def handle_collisions(self):

        pass

    # TODO: methodes privees

    def step(self, actions):

        # Apply the step in the pymunk simulator
        self.agent.pre_step()

        #TODO: add simlation time
        # TODO: add simu accelerate factor for high speed
        # TODO: add scale factor

        self.agent.apply_action(actions)

        for _ in range(SIMULATION_STEPS):
            self.space.step(1. / SIMULATION_STEPS)
        self.reload_screen()

        pygame.image.save(self.screen, 'imgs/'+str(self.ind_image).zfill(10)+'.png')
        self.ind_image += 1

        # TODO: do all timers at once
        # TODO: Generlize, not just for doors
        for door_opener_id in self.timers.copy().keys():
            self.timers[door_opener_id] -= 1

            if self.timers[door_opener_id] < 0:
                door_id = self.relations['actionables']['doors'][door_opener_id]
                door = self.physical_entities[door_id]
                door_opener = self.physical_entities[door_opener_id]

                self.space.add(door.body_body, door.shape_body)
                door_opener.door_closed = True

                # TODO: change
                self.timers.pop(door_opener_id)




        # TODO: update object state for timers and other states

        for yielder_id in self.relations['yielders']:

            if (random.random() < self.yielders[yielder_id].probability) and (len(self.relations['yielders'][yielder_id]) < self.yielders[yielder_id].limit) :

                new_obj = self.yielders[yielder_id].produce()
                id_obj = self.addEntity(new_obj, add_to_basics = False)
                self.relations['yielders'][yielder_id].append(id_obj)

        # TODO: update grasp only when grasp released
        if self.agent.is_releasing == True:

            self.is_holding = False

            for link in self.grasped:
                self.space.remove(link)
            self.grasped = []


        # print(self.agent.reward, self.agent.health)






    def draw(self):

        # debug draw for now
        self.draw_options = pymunk.pygame_util.DrawOptions(self.screen)

        self.space.debug_draw(self.draw_options)
#        self.space.debug_draw(options)

        # Draw the objects
        #for obj in self.entities:
        #    obj.draw(self.screen)

        # Draw the agents
        #self.agent.draw(self.screen)

